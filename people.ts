import { CurrentType, GenderType, RoleType } from "./constants";

type timeType = "AM" | "PM";
export class People {
    get limitation(): People {
        return new People;
    };
    getAlgebraicExpressionOfLove(): string | null {
        return null;
    }
    getVibrationsBy(people: People): any {
        return NaN;
    };
    feelingIndexes = {
        pleasure: {
            HAPPY: 1
        },
        unpleasure: {
            DISHEARTENED: 0
        }
    };
    canSee: boolean = false;
    satisfaction: People | null = null;
    existence: People | null = null;
    execution: People | null = null;
    completion: boolean = false;
    accesses = {
        ERASING: true,
        EXECUTING_EVERYONE: true,
    };
    switchGender(current: GenderType, target: GenderType) { };
    switchRole(current: RoleType, target: RoleType) { };
    fillIn(...parameters: any[]) { };
    initialize() { };
    getDimensions(): { height: number } {
        return {
            height: 200
        };
    };
    getCircumferrence(): number {
        return NaN;
    };
    getNutrients(): number {
        return NaN;
    };
    getAntiOxidants(): number {
        return NaN;
    };
    purrFor(people: People) { };
    sitOn(args: number[]) { };
    getTagents(): number[] { return []; };
    isApproach(nun: number): boolean { return true; };
    switchTo(arg: CurrentType) { };
    unite(people: People) { };
    simulate(num: number): boolean[] { return []; };
    execute(arg: any) {
        return {
            in(world: any) {
                return this;
            },
            trap(me: People, you: People) { }
        };
    };
    createThing(name: string) {
        return {
            from(date: timeType) { return this; },
            to(date: timeType) { return this; },
            do() { }
        };
    };
    trance() { };
    left(people?: People) {
        return {
            in(arg: string) { return this; },
        };
    };
    challenge(people: People) {
        return {
            by(something: string) { }
        }
    };
    goBackTo(people: People): boolean { return true; };
    question(people: People): boolean { return true; };
    escape() { };
    beTrapped() {
        return {
            in(str: string) { }
        };
    };
    async study(something: string) { };
};